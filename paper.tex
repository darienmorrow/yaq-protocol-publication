\documentclass{article}
\usepackage[letterpaper, margin=1in]{geometry}

\title{The yaq Project: a Protocol for Scientific Instrumentation}
\author{Kyle F. Sunden,
  John C. Wright,
  Blaise J. Thompson}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}

Instrumentation development is a key part of the scientific enterprise.
Scientists have always relied on their creativity and wit to assemble new instruments capable of carrying out new experimental procedures.
As the scientific industry has advanced, scientists are increasingly able to directly purchase pieces of their instruments.
A modern instrument might contain a motor from company A, a sensor from company B, a specialty light source from company C, and a totally custom robotic sample stage.
The brand new scientific instrument, doing a brand new experiment, is cobbled together from a few dozen pieces of hardware, some brand new and some reused.
The instrumental novelty arises from the creative way that all of those pieces are assembled and controlled in the context of the experiment.

Software integration can be a frustrating piece of the modern instrument development process.
Each individual component has its own drivers and interface.
A lack of standards means that each scientist must develop her own instrument control application.
Weeks can be spent just integrating one new component into an existing project.
Code reusability is typically poor, and technical debt grows quickly in academic and educational contexts.
Sientists may struggle to rapidly innovate on their experimental design when each hardware addition requires major software development.

Briefly, we
Minimum viable capabilities for desired protocol.
Focus on making client development easy.
\begin{itemize}
  \item Networked machines (subitem--multilingual)
  \item Unified interface (traits)
  \item Self describing
  \item Built on exisiting protocols
  \item Reusable
  \item Synchronous clients
  \item Portable, easy to install
  \item Interface agnostic. Not just serial. Certainly not just SCPI.
\end{itemize}
Well defined, concrete interface.
Static interface.

There are several large exisiting open source hardware interface projects, such as EPICS \cite{DalesioLR1991a}, TANGO \cite{tango-controls.org}, and pymodaq \cite{WeberSebastien2021a}.
These projects are impressive at facility scale, but in our experience these do not scale well to single-investigator lab environments.
We have aimed to keep yaq as simple as possible, with the goal of staying easy to manage at very small scales without dedicated staff.
Certainly yaq lacks features compared to these exisiting projects, as we will highlight.

There are exisiting open source hardware interface projects with a focus on simplicity [cite INSTRBUILDER etc].
To our knowledge none of these meet the minimal capabilities as outlined above.

Overview of this publication.
yaq is a protocol.
yaq is an implementation that runs as a stand-alone daemon.
yaq has a variety of clients.
yaq is not opinonated about orchestration layer.

\section{Protocol}

TCP

\subsection{TCP}

\subsection{Avro RPC}

AVRO-RPC

\subsection{Configuration and State}

configuration

\section{Daemons}

Daemon roundup.

Discussion of traits and purpose of compositional approach.

\subsection{Traits}

Graphic of traits?

Examples of daemons for core traits.

Fakeable.

\section{Clients}

yaq's RPC design invites the creation of multiple client libraries specialized for specific purposes.
Again, daemons can communicate simultaniously with multiple clients.
For a yaq instrument it is normal to have multiple clients running simultaniously, each focused on a particular purpose.
This modularity speeds development and increases overall flexibility of the system.
We have created a few client libraries which we will discuss here.

yaqc [CITE] is a very basic Python client for yaq.
yaqc is totally generic and aims to support any conceivable yaq RPC.
This library is easy to use directly in Python scripts or within the REPL, but it's also very useful as a dependency when building more specialized Python clients.

yaqc-qtpy [CITE] is a specialty Qt-based [CITE] GUI client.
yaqc-qtpy provides a special QClient object which uses Qt threading primatives to provide performant and safe access to yaq from a Qt environment.
In addition, yaqc-qtpy provides an entry point which automatically builds a GUI from arbitrary protocols using traits.
This is an invaluable tool which provides a ``free'' graphical user interface to any daemon.

Bluesky is an extensive open source control layer developed collaboratively across several user facilities \cite{AllanDanielB2019a}.

Bridging to larger open source control layers.
PyMoDaq \cite{WeberSebastien2021a}

\section{Case Studies}

Introductory paragraph.

The Landis Group at UW-Madison created WiQK, a quench kinetics reactor.
Reactions can be orchestrated with a simple script using Python's built-in time library and yaqc.
This has worked for a few years as developers continue to modify their reactor.

The Stahl Group at UW-Madison created a custom reactor which monitors gasses being produced or consumed in the reaction head-space.  \cite{SalazarChaseA2021a}
From an automation control perspective, this reactor incorporates a collection of sensors and a single heating process value under computer control
This reactor was made as a self-contained unit with a Raspberry Pi [CITE] as the computer.
Users interact with a custom Qt-based GUI to use the reactor.
yaq daemons run locally along-side the lightweight Qt application making the entire system simple to run.

The Wright Group needs to orchestrate a large variety of hardware in multidimensional scans for their complex spectroscopy experiments.
We have built out a toolchain incorporating yaq into Bluesky to take advantage of the sophisticated orchestration that Bluesky supports.
We are excited about Bluesky moving forward.

\section{Conclusions}

\clearpage
\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
