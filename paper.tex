\documentclass{article}
\usepackage[letterpaper, margin=1in]{geometry}

\title{The yaq Project: a Protocol for Scientific Instrumentation}
\author{Kyle F. Sunden,
  John C. Wright,
  Blaise J. Thompson}

\begin{document}

\maketitle

\section{Abstract}

\section{Introduction}

Instrumentation development is a key part of the scientific enterprise.
As the scientific industry has advanced, novel instruments are typically constructed of many individual components, purchased and home-built. %scientists are increasingly able to directly purchase pieces of their instruments.
Orchestration software must communicate with each hardware component in the course of a scientific experiment.
This can involve utilization of many protocols: NI DAQmx [CITE], SCPI [CITE], ModBus [CITE], PICam [CITE], Thorlabs APT [CITE], among many others.
The challenge of integrating all of these is a frustrating piece of the modern instrument development process.
Weeks can be spent just integrating one new component into an existing project.
Code reusability is typically poor, and technical debt grows quickly in academic and educational contexts.
Scientists may struggle to rapidly innovate on their experimental design when each hardware addition requires major software development.

Some large user-facilities have addressed protocol complexity via the creation of new unified protcols, EPICS \cite{DalesioLR1991a}, TANGO \cite{tango-controls.org}
The unified protocols define a standard network interface for any hardware component.
Orchestration software can target this unified protocol for reading and writing hardware state.
Small background services are written to translate the myriad component protocols into the standard EPICS IOCs and TANGO Devices.
These programs are peformant, but require expert management to set up and provide descriptions via a separate server program.
These projects are impressive at facility scale, but in our experience these do not scale well to single-investigator lab environments.

As smaller research labs have grown in experimental complexity, many hardware abstraction layers have been produced by individual labs.
Most small custom research instrumentation continues to rely on monolithic home-built orchestration software which has hardcorded protocol support for each particular connected device.
These monolithic applications tend to be very inflexible and difficult to develop.
In the last few years, several open source projects by-and-for small-scale experimentalists have grown in popularity [cite many].
While this growth is encouraging, many of these are limited by their focus on particular types of hardware or particular experimental domains.
To our knowledge, none of these projects take a strict protocol-based approach.
 
We have created a new protocol [XKCD] for scientific instrumentation, yaq.
This protocol attempts to borrow the most important ideas from established projects while retaining simplicity appropriate for small research labs.
We have built this protocol to be self-describing, portable, and reusable wherever possible.
Our primary goal has been to make an interface which simplifies orchestration software development as much as possible.
Here we discuss the design of the yaq ecosystem.
Several case studies provide a view in to the flexible ways that yaq can be applied to perform very different scientific experiments.

\section{Protocol}

The yaq protcol is client-server network based.
To communicate with a given piece of hardware, a client connects to a particular TCP port either locally or to a remote machine over the network.
Once connected, the client will recieve an exhaustive description of what capabilities that particular hardware interface supports.
Clients can connect to many TCP ports and each TCP port can simultaniopusly communicate with many clients.
While Avro RPC itself is agnostic to transport layer, yaq specifies TCP sockets as the transport layer.
TCP socket libraries are ubiquitous, allowing for clients (or daemons) to be implemented in a variety of languages if required.
The use of TCP also works across standard networks, allowing for simple multi-machine instruments.

Apache Avro RPC \cite{AvroSpecification} is used to structure the yaq protcol.
Avro RPC is a Remote Procedure Call framework which allows interprocess communication between a client application and a daemon \(the server\) which has direct hardware access.
Avro provides an agreed upon standard for efficient serialization of data and method calls from a remote \(client\) process.
The protocols defined by Avro are extensible, allowing daemons to define their own data types and declare additional messages that can be processed by the daemon.
Each daemon provides an Avro Protocol file \(avpr\) which provides a complete list of the types and allowed messages.
yaq uses ``stateful'' Avro RPC to allow multiple requests without requiring additional handshaking.

In practice, each hardware interface is exposed to all clients as a set of well-described function calls.

\section{Traits}

Each component of a scientific instrument may have many parameters.
Similar components typically have similar parameters, but there may be incidental differences between each implementation.
For example, consider two different monochromators.
The driver for monochromator A may expose the function "set wavelength", while the driver for monochromator B exposes "set angle".
Any experimentalist wishing to switch from monochromator A to B must first go through their entire codebase to fix all of the small differences in the driver implementation.
yaq is designed using an (optional) compositional system that helps enforce consistency between different kinds of hardware.

yaq defines "traits": collections of behaviors which are logically grouped together.
Each trait specifies a set of configuration options, state entries, and methods that a daemon can implement.
Daemons, then, can be composed of multiple traits.
Clients can trust that daemons which implement a given trait will behave in similar ways.
For example, any daemon that implements the "is-position" trait must expose the methods "get\_position" and "set\_position".
It becomes easy to write generic clients that work with any daemon that has certain traits.
Of course, daemons are always allowed to implement additional configuration, state, and methods in addition to those which are implied by their traits.

\section{Daemons}

In yaq, each component of an instrument is supported by a tiny lightweight process that runs in the background of your computer: a daemon.
Since each component has its own process, each daemon can be developed separately.
Using yaq, a typical instrument might have several daemons each supporting a particular component.
Daemon A might support a motor, daemon B a sensor, and daemon C a light source.
To do an experiment, a control program (a "client") must send commands to each of these daemons.
Each of the daemons is a separate application running in its own process, and importantly the client is also a separate application.

The separation between each daemon and client makes the yaq framework less fragile than monolithic applications.
The yaq framework is language agnostic.
For example, a daemon written in Python might be controlled by a client implemented using LabVIEW.
In yaq, each component of an instrument can be developed and distributed separately.
For example, two very different instruments might happen to use the same temperature sensor.
Because the temperature sensor daemon is its own independent program, both instruments can benefit from the same daemon.
As yaq grows, the "ecosystem" of existing daemons means that future instruments become easier and easier to develop.

There are currently 62 daemons in the yaq project supporting at least 40 kinds of hardware.
Because yaq is protocol based, anyone can design and publish new daemons extending our hardware support.
A living list of all daemons and supported hardware can be found on the yaq website.



\section{Clients}

yaq's RPC design invites the creation of multiple client libraries specialized for specific purposes.
Again, daemons can communicate simultaniously with multiple clients.
For a yaq instrument it is normal to have multiple clients running simultaniously, each focused on a particular purpose.
This modularity speeds development and increases overall flexibility of the system.
We have created a few client libraries which we will discuss here.

yaqc [CITE] is a very basic Python client for yaq.
yaqc is totally generic and aims to support any conceivable yaq RPC.
This library is easy to use directly in Python scripts or within the REPL, but it's also very useful as a dependency when building more specialized Python clients.

yaqc-qtpy [CITE] is a specialty Qt-based [CITE] GUI client.
yaqc-qtpy provides a special QClient object which uses Qt threading primatives to provide performant and safe access to yaq from a Qt environment.
In addition, yaqc-qtpy provides an entry point which automatically builds a GUI from arbitrary protocols using traits.
This is an invaluable tool which provides a ``free'' graphical user interface to any daemon.

Bluesky is an extensive open source control layer developed collaboratively across several user facilities \cite{AllanDanielB2019a}.

Bridging to larger open source control layers.
PyMoDaq \cite{WeberSebastien2021a}

\section{Case Studies}

yaq's simplicity and extensible nature has allowed us to use it in a broad variety of instrumentation designs.
We highlight a few such designs here.

The Landis Group at UW-Madison is currently working on a new type of flow reactor: the Wisconsin Quench Kinetics Reactor (WiQK).
This reactor incorporates several computer-controlled valves and syringe pumps as well as various sensors.
The WiQK is rapidly evolving as researchers continue to test and refine their design.
Only a few researchers are actively using the reactor during this prototyping stage.
The Landis Group has written very basic Python scripts utilizing yaqc to orchestrate hardware for their reactor.
These lightweight scripts can be extensively refactored as the hardware and orchestration strategy changes dramatically during WiQK development.
This approach ensures that the Landis Group is not limited by their ability to orchestrate hardware as they refine their reactor design.

The Stahl Group at UW-Madison created a custom reactor which monitors gasses being produced or consumed in the reaction head-space.  \cite{SalazarChaseA2021a}
This reactor incorporates a collection of sensitive pressure transducers and a single heating process value under computer control.
yaq daemons are used to interface with each sensor and the heater controller.
We were able to create a lightweight Qt-based GUI which offers an easy user experience to researchers.
By separating hardware interface code from GUI code, each piece of the system became easier to produce and maintain.
Taken together, these components have been a solid software experience for many users over several years.

The Wright Group at UW-Madison needs to orchestrate a large variety of hardware in multidimensional scans for their complex spectroscopy experiments \cite{MukamelShaul2000a, WrightJohnCurtis2011a}.
This need for exquisite hardware control has resulted in several prior attempts at ``home-built'' orchestration software \cite{CarlsonRogerJohn1988a, MeyerKentAlbert2004b, KainSchuyler2017a, ThompsonBlaiseJonathan2018a}.
Now, using yaq, the Wright Group has been able to move to Bluesky rather than inventing their own sophisticated control software ``from scratch''.
Moving forward, the Wright Group hopes to spend less energy developing control software and more energy developing creative spectroscopy experiments.

yaq is also being used in several smaller ways throughout UW-Madison Chemistry.
Excitingly, all of these research groups are able easily benefit from each-other's daemon developments.
This level of collaboration is new to us in the orchestration software space.

\section{Conclusions}

\clearpage
\bibliographystyle{unsrt}
\bibliography{references}

\end{document}
